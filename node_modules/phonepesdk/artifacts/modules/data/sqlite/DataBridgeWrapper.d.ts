import { NativeDataBridgeContract } from './NativeDataBridgeContract';
import { EmitterSubscription } from 'react-native';
export interface InitialiseCallback {
    (data?: any): void;
}
export interface DataResultCallback<T> {
    (data: T): void;
}
export interface DataErrorCallback {
    (data: Error): void;
}
export declare abstract class DataBridgeWrapper {
    private dataBridge;
    private currentState;
    private callbacks;
    constructor(dataBridge: NativeDataBridgeContract, _name: string);
    private initialiseInternal(dataInitCallback);
    private addCallback(dataInitCallback);
    initialise(callback: InitialiseCallback): void;
    addEmitterListener(eventType: string, listener: (...args: any[]) => any, context?: any): EmitterSubscription;
    query(tableName: string, callback: DataResultCallback<any[]>, columns?: string[], selection?: string, selectionArgs?: any[], groupBy?: string, having?: string, orderBy?: string): void;
    querySync(tableName: string, columns?: string[], selection?: string, selectionArgs?: any[], groupBy?: string, having?: string, orderBy?: string): Promise<any[]>;
    queryWithLimit(tableName: string, limit: number, columns?: string[], selection?: string, selectionArgs?: any[], groupBy?: string, having?: string, orderBy?: string, callback?: DataResultCallback<any[]>): void;
    startTransaction(callback?: DataResultCallback<any>): void;
    endTransaction(callback?: DataResultCallback<any>): void;
    setTransactionSuccessful(callback?: DataResultCallback<any>): void;
    deleteRow(tableName: string, selectionCriteria?: string, selectionArgs?: any[], callback?: DataResultCallback<number>): void;
    deleteRowSync(tableName: string, selectionCriteria?: string, selectionArgs?: any[]): Promise<number>;
    execSQL(sqlStatement: string, forceExecution: boolean | undefined, callback: DataResultCallback<any>): void;
    execSQLSync(sqlStatement: string): Promise<any>;
    rawQuery(sql?: string, selectionArgs?: any[], callback?: DataResultCallback<any[]>): void;
    setParallelThread(corePoolSize: number, maximumPoolSize: number, keepAliveTime: number): void;
    beginStreamingData(table: string, limit: number, streamId: string, columns?: string[], selection?: string, selectionArgs?: any[], groupBy?: string, having?: string, orderBy?: string, callback?: DataResultCallback<any[]>): void;
    nextData(streamId: string, start: number, count: number, callback?: DataResultCallback<any[]>): void;
    endData(streamId: string, callback?: DataResultCallback<boolean>): void;
    update(table: string, values: {
        [key: string]: any;
    }, whereClause?: string, whereArgs?: any[], callback?: DataResultCallback<number>): void;
    updateSync(table: string, values: {
        [key: string]: any;
    }, whereClause?: string, whereArgs?: any[], _callback?: DataResultCallback<number>): Promise<number>;
    insertWithOnConflict(table: string, initialValues: {
        [key: string]: any;
    }, conflictAlgorithm: number, nullColumnHack?: string, callback?: DataResultCallback<number>): void;
    insertWithOnConflictSync(table: string, initialValues: {
        [key: string]: any;
    }, conflictAlgorithm: number, nullColumnHack?: string): Promise<number>;
    bulkInsertWithOnConflict(table: string, initialColumns: Array<string>, initialValues: Array<Array<any>>, conflictAlgorithm: number, nullColumnHack?: string, callback?: DataResultCallback<number>): void;
    bulkInsertWithOnConflictSync(table: string, initialColumns: Array<string>, initialValues: Array<Array<any>>, conflictAlgorithm: number, nullColumnHack?: string): Promise<number>;
    addListener(eventId: string, callback?: DataResultCallback<any>): void;
    addListenerForSpecificTable(eventId: string, tableName: string, callback?: DataResultCallback<any>): void;
    addListenerForSpecificTableSync(eventId: string, tableName: string): Promise<any>;
    removeListener(eventId: string, callback?: DataResultCallback<any>): void;
}
