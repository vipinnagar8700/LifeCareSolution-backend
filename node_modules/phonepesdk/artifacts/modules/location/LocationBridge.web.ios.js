"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const PhonePeWebSubscription_1 = require("./../../subscription/PhonePeWebSubscription");
const PhonePeSDKWebConstants_1 = require("./../../constants/PhonePeSDKWebConstants");
const EventHandler_1 = require("../../core/web/EventHandler");
var Const = PhonePeSDKWebConstants_1.PhonePeSDKWebConstants.Location;
class WebLocationBridgeiOS {
    getAddress(latitude, longitude) {
        return Promise.reject('METHOD_NOT_SUPPORTED');
    }
    startUpdatingLocation() {
        if (navigator.geolocation) {
            this.watchId = navigator.geolocation.watchPosition(WebLocationBridgeiOS.watchSuccessCallback.bind(this), WebLocationBridgeiOS.watchErrorCallback.bind(this));
        }
    }
    stopUpdatingLocation() {
        if (navigator.geolocation) {
            if (this.watchId) {
                navigator.geolocation.clearWatch(this.watchId);
            }
        }
    }
    static watchSuccessCallback(location) {
        EventHandler_1.EventHandler.sendEvent(Const.locationSuccessEventKey, JSON.stringify({
            latitude: location.coords.latitude,
            longitude: location.coords.longitude
        }));
    }
    static watchErrorCallback(error) {
        EventHandler_1.EventHandler.sendEvent(Const.locationSuccessEventKey, error.message);
    }
    getCurrentLocation() {
        return new Promise((resolve, reject) => {
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition((location) => {
                    resolve(JSON.stringify({
                        'latitude': location.coords.latitude,
                        'longitude': location.coords.longitude
                    }));
                }, (error) => {
                    reject('LOCATION_FETCH_FAILURE');
                });
            }
            else {
                reject('INTERNAL_ERROR');
            }
        });
    }
    onLocationUpdateSuccess(callbackName, callback) {
        let subscription = new PhonePeWebSubscription_1.PhonePeWebSubscription(callbackName, Const.locationSuccessEventKey, callback);
        EventHandler_1.EventHandler.addSubscription(subscription);
        return subscription;
    }
    onLocationUpdateFailure(callbackName, callback) {
        let subscription = new PhonePeWebSubscription_1.PhonePeWebSubscription(callbackName, Const.locationFailureEventKey, callback);
        EventHandler_1.EventHandler.addSubscription(subscription);
        return subscription;
    }
    isLocationTurnedOn() {
        return Promise.resolve();
    }
    turnOnLocation() {
        return Promise.resolve();
    }
    setLocationPriority(locationPriority) {
    }
}
exports.WebLocationBridgeiOS = WebLocationBridgeiOS;
