"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const QueryBuilder_ios_1 = require("./QueryBuilder.ios");
const react_native_1 = require("react-native");
class IosNativeDataBridge {
    constructor(databaseName, dataBridge) {
        this.databaseName = databaseName;
        this.dataBridge = dataBridge;
        this.databaseEventEmitter = new react_native_1.NativeEventEmitter(dataBridge);
    }
    query(tableName, columns, selection, selectionArgs, groupBy, having, orderBy) {
        let query = QueryBuilder_ios_1.QueryBuilder.read(tableName, columns, selection, groupBy, having, orderBy);
        return this.dataBridge.executeSqliteSelect(this.databaseName, query, selectionArgs);
    }
    queryWithLimit(tableName, limit, columns, selection, selectionArgs, groupBy, having, orderBy) {
        let query = QueryBuilder_ios_1.QueryBuilder.read(tableName, columns, selection, groupBy, having, orderBy, limit);
        return this.dataBridge.executeSqliteSelect(this.databaseName, query, selectionArgs);
    }
    startTransaction() {
        return this.dataBridge.startTransaction(this.databaseName);
    }
    endTransaction() {
        return this.dataBridge.endTransaction(this.databaseName);
    }
    setTransactionSuccessful() {
        return this.dataBridge.setTransactionSuccessful(this.databaseName);
    }
    deleteRow(tableName, selectionCriteria, selectionArgs) {
        let query = QueryBuilder_ios_1.QueryBuilder.delete(tableName, selectionCriteria);
        return this.dataBridge.executeSqliteUpdate(this.databaseName, query, tableName, selectionArgs);
    }
    execSQL(sqlStatement) {
        return this.dataBridge.executeSqliteUpdate(this.databaseName, sqlStatement, undefined, undefined);
    }
    rawQuery(sql, selectionArgs) {
        return this.dataBridge.executeSqliteSelect(this.databaseName, sql, selectionArgs);
    }
    setParallelThread(_corePoolSize, _maximumPoolSize, _keepAliveTime) {
    }
    beginStreamingData(table, limit, streamId, columns, selection, selectionArgs, groupBy, having, orderBy) {
        let query = QueryBuilder_ios_1.QueryBuilder.read(table, columns, selection, groupBy, having, orderBy, undefined, undefined);
        return this.dataBridge.beginStreamingData(this.databaseName, streamId, query, limit, selectionArgs);
    }
    nextData(streamId, start, count) {
        return this.dataBridge.nextDataInStream(this.databaseName, streamId, start, count);
    }
    endData(streamId) {
        return this.dataBridge.endStream(this.databaseName, streamId);
    }
    update(tableName, values, whereClause, whereArgs) {
        let query = QueryBuilder_ios_1.QueryBuilder.update(tableName, values, whereClause);
        return this.dataBridge.executeSqliteUpdate(this.databaseName, query, tableName, whereArgs);
    }
    insertWithOnConflict(tableName, initialValues, conflictAlgorithm, _nullColumnHack) {
        let query = QueryBuilder_ios_1.QueryBuilder.insertWithOnConflict(tableName, initialValues, conflictAlgorithm);
        return this.dataBridge.executeSqliteUpdate(this.databaseName, query, tableName, undefined);
    }
    bulkInsertWithOnConflict(tableName, initialColumns, initialValues, conflictAlgorithm, _nullColumnHack) {
        return Promise.reject(new Error('Method not available'));
    }
    addListener(eventId) {
        return this.dataBridge.addListener(this.databaseName, eventId);
    }
    addListenerForSpecificTable(eventId, tableName) {
        return this.dataBridge.addListenerForSpecificTable(this.databaseName, eventId, tableName);
    }
    removeListener(eventId) {
        return this.dataBridge.removeListener(this.databaseName, eventId);
    }
    addEmitterListener(eventType, listener, context) {
        return this.databaseEventEmitter.addListener(eventType, listener, context);
    }
}
exports.IosNativeDataBridge = IosNativeDataBridge;
