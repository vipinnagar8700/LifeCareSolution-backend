"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const react_native_1 = require("react-native");
const PhonePeSDKExternalConstants_1 = require("../../../constants/PhonePeSDKExternalConstants");
const AnalyticsHelper_1 = require("../../../utils/AnalyticsHelper");
var Species = PhonePeSDKExternalConstants_1.ExternalConstants.Species;
class AndroidNativeDataBridge {
    constructor(databaseName, dataBridge) {
        this.databaseName = databaseName;
        this.dataBridge = dataBridge;
        this.databaseEventEmitter = new react_native_1.NativeEventEmitter(dataBridge);
        this.logMerchantEvent = AnalyticsHelper_1.AnalyticsBridgeUtil.getEventLoggerForBridge(Species.native, react_native_1.Platform.OS, 'DATABASE_BRIDGE_EVENT');
    }
    query(tableName, columns, selection, selectionArgs, groupBy, having, orderBy) {
        return new Promise((resolve, reject) => {
            const methodName = 'query';
            this.logMerchantEvent(methodName, 'START');
            this.dataBridge.query(this.databaseName, tableName, columns, selection, selectionArgs, groupBy, having, orderBy)
                .then((res) => {
                this.logMerchantEvent(methodName, 'SUCCESS');
                resolve(res);
            })
                .catch((err) => {
                this.logMerchantEvent(methodName, 'FAILED', JSON.stringify(err));
                reject(err);
            });
        });
    }
    queryWithLimit(tableName, limit, columns, selection, selectionArgs, groupBy, having, orderBy) {
        return new Promise((resolve, reject) => {
            const methodName = 'queryWithLimit';
            this.logMerchantEvent(methodName, 'START');
            this.dataBridge.queryWithLimit(this.databaseName, tableName, columns, selection, selectionArgs, groupBy, having, orderBy, limit)
                .then((res) => {
                this.logMerchantEvent(methodName, 'SUCCESS');
                resolve(res);
            })
                .catch((err) => {
                this.logMerchantEvent(methodName, 'FAILED', JSON.stringify(err));
                reject(err);
            });
        });
    }
    startTransaction() {
        return new Promise((resolve, reject) => {
            const methodName = 'startTransaction';
            this.logMerchantEvent(methodName, 'START');
            this.dataBridge.startTransaction(this.databaseName)
                .then((res) => {
                this.logMerchantEvent(methodName, 'SUCCESS');
                resolve(res);
            })
                .catch((err) => {
                this.logMerchantEvent(methodName, 'FAILED', JSON.stringify(err));
                reject(err);
            });
        });
    }
    endTransaction() {
        return new Promise((resolve, reject) => {
            const methodName = 'endTransaction';
            this.logMerchantEvent(methodName, 'START');
            this.dataBridge.endTransaction(this.databaseName)
                .then((res) => {
                this.logMerchantEvent(methodName, 'SUCCESS');
                resolve(res);
            })
                .catch((err) => {
                this.logMerchantEvent(methodName, 'FAILED', JSON.stringify(err));
                reject(err);
            });
        });
    }
    setTransactionSuccessful() {
        return new Promise((resolve, reject) => {
            const methodName = 'setTransactionSuccessful';
            this.logMerchantEvent(methodName, 'START');
            this.dataBridge.setTransactionSuccessful(this.databaseName)
                .then((res) => {
                this.logMerchantEvent(methodName, 'SUCCESS');
                resolve(res);
            })
                .catch((err) => {
                this.logMerchantEvent(methodName, 'FAILED', JSON.stringify(err));
                reject(err);
            });
        });
    }
    deleteRow(tableName, selectionCriteria, selectionArgs) {
        return new Promise((resolve, reject) => {
            const methodName = 'deleteRow';
            this.logMerchantEvent(methodName, 'START');
            this.dataBridge.delete(this.databaseName, tableName, selectionCriteria, selectionArgs)
                .then((res) => {
                this.logMerchantEvent(methodName, 'SUCCESS');
                resolve(res);
            })
                .catch((err) => {
                this.logMerchantEvent(methodName, 'FAILED', JSON.stringify(err));
                reject(err);
            });
        });
    }
    execSQL(sqlStatement) {
        return new Promise((resolve, reject) => {
            const methodName = 'execSQL';
            this.logMerchantEvent(methodName, 'START');
            this.dataBridge.execSQL(this.databaseName, sqlStatement)
                .then((res) => {
                this.logMerchantEvent(methodName, 'SUCCESS');
                resolve(res);
            })
                .catch((err) => {
                this.logMerchantEvent(methodName, 'FAILED', JSON.stringify(err));
                reject(err);
            });
        });
    }
    rawQuery(sql, selectionArgs) {
        return new Promise((resolve, reject) => {
            const methodName = 'rawQuery';
            this.logMerchantEvent(methodName, 'START');
            this.dataBridge.rawQuery(this.databaseName, sql, selectionArgs)
                .then((res) => {
                this.logMerchantEvent(methodName, 'SUCCESS');
                resolve(res);
            })
                .catch((err) => {
                this.logMerchantEvent(methodName, 'FAILED', JSON.stringify(err));
                reject(err);
            });
        });
    }
    setParallelThread(corePoolSize, maximumPoolSize, keepAliveTime) {
        this.dataBridge.setParallelThread(this.databaseName, corePoolSize, maximumPoolSize, keepAliveTime);
    }
    beginStreamingData(table, limit, streamId, columns, selection, selectionArgs, groupBy, having, orderBy) {
        return this.dataBridge.beginStreamingData(this.databaseName, table, columns, selection, selectionArgs, groupBy, having, orderBy, limit, streamId);
    }
    nextData(streamId, start, count) {
        return this.dataBridge.nextData(this.databaseName, streamId, start, count);
    }
    endData(streamId) {
        return this.dataBridge.stop(this.databaseName, streamId);
    }
    update(table, values, whereClause, whereArgs) {
        return new Promise((resolve, reject) => {
            const methodName = 'update';
            this.logMerchantEvent(methodName, 'START');
            this.dataBridge.update(this.databaseName, table, values, whereClause, whereArgs)
                .then((res) => {
                this.logMerchantEvent(methodName, 'SUCCESS');
                resolve(res);
            })
                .catch((err) => {
                this.logMerchantEvent(methodName, 'FAILED', JSON.stringify(err));
                reject(err);
            });
        });
    }
    insertWithOnConflict(table, initialValues, conflictAlgorithm, nullColumnHack) {
        return new Promise((resolve, reject) => {
            const methodName = 'insertWithOnConflict';
            this.logMerchantEvent(methodName, 'START');
            this.dataBridge.insertWithOnConflict(this.databaseName, table, nullColumnHack, initialValues, conflictAlgorithm)
                .then((res) => {
                this.logMerchantEvent(methodName, 'SUCCESS');
                resolve(res);
            })
                .catch((err) => {
                this.logMerchantEvent(methodName, 'FAILED', JSON.stringify(err));
                reject(err);
            });
        });
    }
    bulkInsertWithOnConflict(table, initialColumns, initialValues, conflictAlgorithm, nullColumnHack) {
        if (this.dataBridge.bulkInsertOnConflict) {
            return new Promise((resolve, reject) => {
                const methodName = 'bulkInsertWithOnConflict';
                this.logMerchantEvent(methodName, 'START');
                this.dataBridge.bulkInsertOnConflict(this.databaseName, table, nullColumnHack, initialColumns, initialValues, conflictAlgorithm)
                    .then((res) => {
                    this.logMerchantEvent(methodName, 'SUCCESS');
                    resolve(res);
                })
                    .catch((err) => {
                    this.logMerchantEvent(methodName, 'FAILED', JSON.stringify(err));
                    reject(err);
                });
            });
        }
        return new Promise((resolve, reject) => {
            let totalRows = initialValues.length;
            let successCount = 0;
            for (let value of initialValues) {
                const contentValue = {};
                if (value.length !== initialColumns.length) {
                    reject(`Mismatch between number of columns and row columns. Row column count: ${value.length}, Column count: ${initialColumns.length}. Rows inserted: ${successCount}.`);
                }
                for (let index = 0; index < value.length; index += 1) {
                    const column = initialColumns[index];
                    const data = value[index];
                    contentValue[column] = data;
                }
                this.dataBridge.insertWithOnConflict(this.databaseName, table, nullColumnHack, contentValue, conflictAlgorithm)
                    .then(() => {
                    successCount++;
                })
                    .catch((err) => {
                    reject(err);
                })
                    .finally(() => {
                    totalRows--;
                    if (!totalRows) {
                        resolve(successCount);
                    }
                });
            }
        });
    }
    addListener(eventId) {
        return this.dataBridge.addListener(this.databaseName, eventId);
    }
    addListenerForSpecificTable(eventId, tableName) {
        return this.dataBridge.addListenerForSpecificTable(this.databaseName, eventId, tableName);
    }
    removeListener(eventId) {
        return this.dataBridge.removeListener(this.databaseName, eventId);
    }
    addEmitterListener(eventType, listener, context) {
        return this.databaseEventEmitter.addListener(eventType, listener, context);
    }
}
exports.AndroidNativeDataBridge = AndroidNativeDataBridge;
