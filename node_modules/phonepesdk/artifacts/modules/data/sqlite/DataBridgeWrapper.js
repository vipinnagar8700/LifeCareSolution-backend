"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
var DataBridgeInitStatus;
(function (DataBridgeInitStatus) {
    DataBridgeInitStatus[DataBridgeInitStatus["NOT_INITIALIZED"] = 0] = "NOT_INITIALIZED";
    DataBridgeInitStatus[DataBridgeInitStatus["INITIALIZING"] = 1] = "INITIALIZING";
    DataBridgeInitStatus[DataBridgeInitStatus["INITIALIZED"] = 2] = "INITIALIZED";
})(DataBridgeInitStatus || (DataBridgeInitStatus = {}));
class DataBridgeWrapper {
    constructor(dataBridge, _name) {
        this.currentState = DataBridgeInitStatus.NOT_INITIALIZED;
        this.callbacks = [];
        this.dataBridge = dataBridge;
    }
    initialiseInternal(dataInitCallback) {
        switch (this.currentState) {
            case DataBridgeInitStatus.INITIALIZING:
                this.addCallback(dataInitCallback);
                break;
            case DataBridgeInitStatus.INITIALIZED:
                dataInitCallback();
                return;
            default:
            case DataBridgeInitStatus.NOT_INITIALIZED:
                this.addCallback(dataInitCallback);
                this.currentState = DataBridgeInitStatus.INITIALIZING;
                this.initialise(() => {
                    this.currentState = DataBridgeInitStatus.INITIALIZED;
                    for (let callback of this.callbacks)
                        callback();
                });
                break;
        }
    }
    addCallback(dataInitCallback) {
        this.callbacks[this.callbacks.length] = dataInitCallback;
    }
    initialise(callback) {
        callback();
    }
    addEmitterListener(eventType, listener, context) {
        return this.dataBridge.addEmitterListener(eventType, listener, context);
    }
    query(tableName, callback, columns, selection, selectionArgs, groupBy, having, orderBy) {
        this.initialiseInternal(() => __awaiter(this, void 0, void 0, function* () {
            callback(yield this.dataBridge.query(tableName, columns, selection, selectionArgs, groupBy, having, orderBy));
        }));
    }
    querySync(tableName, columns, selection, selectionArgs, groupBy, having, orderBy) {
        return this.dataBridge.query(tableName, columns, selection, selectionArgs, groupBy, having, orderBy);
    }
    queryWithLimit(tableName, limit, columns, selection, selectionArgs, groupBy, having, orderBy, callback) {
        this.initialiseInternal(() => __awaiter(this, void 0, void 0, function* () {
            let result = yield this.dataBridge.queryWithLimit(tableName, limit, columns, selection, selectionArgs, groupBy, having, orderBy);
            if (callback != undefined)
                callback(result);
        }));
    }
    startTransaction(callback) {
        this.initialiseInternal(() => __awaiter(this, void 0, void 0, function* () {
            let result = yield this.dataBridge.startTransaction();
            if (callback != undefined)
                callback(result);
        }));
    }
    endTransaction(callback) {
        this.initialiseInternal(() => __awaiter(this, void 0, void 0, function* () {
            let result = yield this.dataBridge.endTransaction();
            if (callback != undefined)
                callback(result);
        }));
    }
    setTransactionSuccessful(callback) {
        this.initialiseInternal(() => __awaiter(this, void 0, void 0, function* () {
            let result = yield this.dataBridge.setTransactionSuccessful();
            if (callback != undefined)
                callback(result);
        }));
    }
    deleteRow(tableName, selectionCriteria, selectionArgs, callback) {
        this.initialiseInternal(() => __awaiter(this, void 0, void 0, function* () {
            let result = yield this.dataBridge.deleteRow(tableName, selectionCriteria, selectionArgs);
            if (callback != undefined)
                callback(result);
        }));
    }
    deleteRowSync(tableName, selectionCriteria, selectionArgs) {
        return this.dataBridge.deleteRow(tableName, selectionCriteria, selectionArgs);
    }
    execSQL(sqlStatement, forceExecution = false, callback) {
        if (forceExecution)
            callback(this.dataBridge.execSQL(sqlStatement));
        else
            this.initialiseInternal(() => {
                callback(this.dataBridge.execSQL(sqlStatement));
            });
    }
    execSQLSync(sqlStatement) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.dataBridge.execSQL(sqlStatement);
        });
    }
    rawQuery(sql, selectionArgs, callback) {
        this.initialiseInternal(() => __awaiter(this, void 0, void 0, function* () {
            let result = yield this.dataBridge.rawQuery(sql, selectionArgs);
            if (callback != undefined)
                callback(result);
        }));
    }
    setParallelThread(corePoolSize, maximumPoolSize, keepAliveTime) {
        this.dataBridge.setParallelThread(corePoolSize, maximumPoolSize, keepAliveTime);
    }
    beginStreamingData(table, limit, streamId, columns, selection, selectionArgs, groupBy, having, orderBy, callback) {
        this.initialiseInternal(() => __awaiter(this, void 0, void 0, function* () {
            let result = yield this.dataBridge.beginStreamingData(table, limit, streamId, columns, selection, selectionArgs, groupBy, having, orderBy);
            if (callback != undefined)
                callback(result);
        }));
    }
    nextData(streamId, start, count, callback) {
        this.initialiseInternal(() => __awaiter(this, void 0, void 0, function* () {
            let result = yield this.dataBridge.nextData(streamId, start, count);
            if (callback != undefined)
                callback(result);
        }));
    }
    endData(streamId, callback) {
        this.initialiseInternal(() => __awaiter(this, void 0, void 0, function* () {
            let result = yield this.dataBridge.endData(streamId);
            if (callback != undefined)
                callback(result);
        }));
    }
    update(table, values, whereClause, whereArgs, callback) {
        this.initialiseInternal(() => __awaiter(this, void 0, void 0, function* () {
            let result = yield this.dataBridge.update(table, values, whereClause, whereArgs);
            if (callback != undefined)
                callback(result);
        }));
    }
    updateSync(table, values, whereClause, whereArgs, _callback) {
        return this.dataBridge.update(table, values, whereClause, whereArgs);
    }
    insertWithOnConflict(table, initialValues, conflictAlgorithm, nullColumnHack, callback) {
        this.initialiseInternal(() => __awaiter(this, void 0, void 0, function* () {
            let result = yield this.dataBridge.insertWithOnConflict(table, initialValues, conflictAlgorithm, nullColumnHack);
            if (callback != undefined)
                callback(result);
        }));
    }
    insertWithOnConflictSync(table, initialValues, conflictAlgorithm, nullColumnHack) {
        return this.dataBridge.insertWithOnConflict(table, initialValues, conflictAlgorithm, nullColumnHack);
    }
    bulkInsertWithOnConflict(table, initialColumns, initialValues, conflictAlgorithm, nullColumnHack, callback) {
        this.initialiseInternal(() => __awaiter(this, void 0, void 0, function* () {
            let result = yield this.dataBridge.bulkInsertWithOnConflict(table, initialColumns, initialValues, conflictAlgorithm, nullColumnHack);
            if (callback != undefined)
                callback(result);
        }));
    }
    bulkInsertWithOnConflictSync(table, initialColumns, initialValues, conflictAlgorithm, nullColumnHack) {
        return this.dataBridge.bulkInsertWithOnConflict(table, initialColumns, initialValues, conflictAlgorithm, nullColumnHack);
    }
    addListener(eventId, callback) {
        this.initialiseInternal(() => __awaiter(this, void 0, void 0, function* () {
            let result = yield this.dataBridge.addListener(eventId);
            if (callback != undefined)
                callback(result);
        }));
    }
    addListenerForSpecificTable(eventId, tableName, callback) {
        this.initialiseInternal(() => __awaiter(this, void 0, void 0, function* () {
            let result = yield this.dataBridge.addListenerForSpecificTable(eventId, tableName);
            if (callback != undefined)
                callback(result);
        }));
    }
    addListenerForSpecificTableSync(eventId, tableName) {
        return this.dataBridge.addListenerForSpecificTable(eventId, tableName);
    }
    removeListener(eventId, callback) {
        this.initialiseInternal(() => __awaiter(this, void 0, void 0, function* () {
            let result = yield this.dataBridge.removeListener(eventId);
            if (callback != undefined)
                callback(result);
        }));
    }
}
exports.DataBridgeWrapper = DataBridgeWrapper;
