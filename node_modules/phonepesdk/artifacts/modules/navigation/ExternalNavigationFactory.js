"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const OriginInfo_1 = require("./../analytics/OriginInfo");
const ExternalPaymentsRequestFactory_1 = require("../payment/ExternalPaymentsRequestFactory");
const NavigationRequest_1 = require("./NavigationRequest");
const models_1 = require("./../payment/models");
const AnalyticsInfo_1 = require("../analytics/AnalyticsInfo");
var Constant = models_1.ExternalPaymentsNamespace.Constant;
class ExternalNavigationFactory {
    static genericPaymentNavigationRequest(reservationId, fallbackURL) {
        const payRequest = new NavigationRequest_1.GenericPaymentNavigationRequest('Pay', true, false, reservationId, fallbackURL);
        return payRequest;
    }
    static paymentNavigationRequest(merchantName, context, version, fallbackURL, imageURL, orderedMetaData, confirmationActionButtonProperties) {
        let amount = context[models_1.ExternalPaymentsNamespace.Constant.kPayableAmount];
        let timeoutInterval = context[models_1.ExternalPaymentsNamespace.Constant.kValidFor];
        if (timeoutInterval) {
            timeoutInterval *= 1000;
        }
        let merchantId = context[Constant.kMerchantId];
        let uiConfig = ExternalPaymentsRequestFactory_1.ExternalPaymentsRequestFactory.internalPaymentUIConfig(amount, merchantName, timeoutInterval, imageURL, confirmationActionButtonProperties, merchantId);
        let microPayRequest = ExternalPaymentsRequestFactory_1.ExternalPaymentsRequestFactory.microPayRequest(context, version, fallbackURL);
        let paymentMetadata = new NavigationRequest_1.PaymentMetaData([{}]);
        if (orderedMetaData !== undefined) {
            let data = [];
            for (let singleMetaMap of orderedMetaData) {
                for (let k in singleMetaMap) {
                    if (singleMetaMap.hasOwnProperty(k)) {
                        let key = k;
                        let value = singleMetaMap[k];
                        let localMap = {};
                        localMap[Constant.kKey] = key;
                        localMap[Constant.kValue] = value;
                        data.push(localMap);
                    }
                }
            }
            paymentMetadata.details = data;
        }
        let serviceCategory = context[Constant.kServiceCategory];
        if (!serviceCategory) {
            serviceCategory = 'JSSDK';
        }
        let originInfo = new OriginInfo_1.OriginInfo(new AnalyticsInfo_1.AnalyticsInfo(serviceCategory, serviceCategory + '_NAVIGATE_TO_PAYMENTS', Math.random().toString(36).substring(7)));
        let paymentRequest = new NavigationRequest_1.PaymentNavigationRequest('Pay', 'Pay', true, false, models_1.ExternalPaymentsNamespace.PAYMENT_MODE.MODE_SEND_MONEY, microPayRequest, uiConfig, models_1.ExternalPaymentsNamespace.TRANSACTION_TYPE.SENT_PAYMENT, paymentMetadata, originInfo);
        return paymentRequest;
    }
    static transactionDetailRequest(transactionId) {
        let category = 'JSSDK';
        let originInfo = new OriginInfo_1.OriginInfo(new AnalyticsInfo_1.AnalyticsInfo(category, category + '_NAVIGATE_TO_TRANSACTION_DETAILS', Math.random().toString(36).substring(7)));
        let request = new NavigationRequest_1.TransactionDetailsNavigationRequest('Details', 'Details', true, false, transactionId, models_1.ExternalPaymentsNamespace.TRANSACTION_TYPE.SENT_PAYMENT, originInfo);
        return request;
    }
}
exports.ExternalNavigationFactory = ExternalNavigationFactory;
